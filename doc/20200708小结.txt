用工场模式模拟类
函数第一个字母大写 约定俗成表示一个类
new 关键字 传递参数 执行模版代码 返回对象
instanceof判断一个对象是否是另外一个对象的实例
原型 prototype
内部构造函数的引用会多次创建新实例 因此要放到外面
prototype 每个创建函数都有一个 prototype对象 这个对象其实是一个指针,这个指针总指向一个对象
这个对象的用途就是将特定的属性和方法包含在内,起一个所有实例共享的作用
构造函数.prototype= 原型对象   原型对象.constructor=构造函数    实例对象.prototype=原型对象
读取对象属性时先搜索实例对象里name的属性,如果没有再去搜索原型对象里name的属性,都没有则返回undefined,可以存储原型用于数据恢复
delete删除实例对象里的属性
hasOwnProperty() 判断一个属性是属于原型还是实例
in 判断属性是否存在实例对象和原型对象中 只要存在于其中一个就返回true
判断属性是否在原型中存在的方法: 1:判断是否在实例中存在(hasOwnProperty) 2:判断属性是否存在(in) 3:相与后得到是否在原型中存在
ECMA5新特性:Object.Keys拿到当前对象所有Keys 返回一个对象内所有属性的数组
forEach 循环遍历数组每一项 只适合遍历一维数组
ECMA5给原型对象重新设置构造器的方法 Object.definePropery( , , );参数1:重设构造器对象 参数2;设置什么属性 参数3:option配置项
原型的动态特性:实例对象在原型对象后创建
原型和构造函数组合模式:动态原型方法 稳妥构造函数式 没有this对象 没有关键字 在非常安全的环境中
让子类的原型对象等于父类的实例,结果会怎样(实现了JS的继承)
此时原型对象包含指向另一个原型的指针
Sup的实例对象和Sup的原型对象 有一个关系
相应的另一个原型也包含一个指向另一个构造函数的指针
子类的原型的对象构造器变成了父类的构造器
原型继承:继承父类的模版和原型对象
类继承:继承父类模版
原型加借用构造函数=混合继承 缺点:继承了父类2次模版 一次原型对象